<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Volcano-Style Optimizer Full Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
h1 { font-size: 20px; margin-bottom: 8px; }
.grid { display:grid; grid-template-columns:360px 1fr; gap:16px; }
.card { background:#fff; padding:12px; border-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,0.05);}
textarea,input[type=text]{width:100%; font-family:monospace; font-size:13px;}
pre{background:#f0f8ff;padding:8px;border-radius:6px;font-size:13px;white-space:pre-wrap;}
button{padding:8px 12px;border-radius:6px;background:#0b66ff;color:white;border:none;cursor:pointer;}
button.alt{background:#eef6ff;color:#03306a;border:1px solid #dbeeff;}
svg{border:1px solid #ddd; margin-top:8px;}
</style>
</head>
<body>
<h1>Volcano-Style Query Optimizer — Full Demo</h1>

<div class="grid">
<div class="card">
<label>Tables (name:rows:hasIndex) comma-separated</label>
<input id="tablesInput" type="text" value="A:1000:1,B:5000:0,C:2000:1">
<small>1=index available, 0=no index</small>

<label style="margin-top:10px">Filters/predicates (table condition selectivity)</label>
<textarea id="predicatesInput" rows="4">A col1>5 0.1
C colX=10 0.05</textarea>

<label style="margin-top:10px">Joins (left right selectivity)</label>
<textarea id="joinsInput" rows="4">A B 0.01
B C 0.01</textarea>

<label style="margin-top:10px">Cost parameters</label>
<div style="display:flex;gap:8px">
<div style="flex:1">
<input id="ioRow" type="text" value="1.0"><small>IO per row</small>
</div>
<div style="flex:1">
<input id="cpuRow" type="text" value="0.1"><small>CPU per row</small>
</div>
</div>

<div style="margin-top:12px" class="row">
<button id="runBtn">Run optimizer</button>
<button id="resetBtn" class="alt">Reset</button>
</div>
</div>

<div class="card">
<label>DP table / intermediate results</label>
<div id="dpOut"><pre>(run optimizer)</pre></div>

<label style="margin-top:10px">Best join order & cost</label>
<div id="bestOut"><pre>(run optimizer)</pre></div>

<label style="margin-top:10px">Plan tree (SVG)</label>
<div id="svgContainer"><svg id="planSvg" width="100%" height="400"></svg></div>
</div>
</div>

<script>
// ---------- Parsing ----------
function parseTables(input){
    const pairs = input.split(",").map(s=>s.trim()).filter(Boolean);
    const names=[]; const sizes={}; const indexes={};
    for(const p of pairs){
        const [name,rowsStr,idxStr]=p.split(":").map(x=>x.trim());
        if(!name) continue;
        const rows=parseInt(rowsStr||"1000"); const idx=idxStr==="1";
        names.push(name); sizes[name]=rows; indexes[name]=idx;
    }
    return {names,sizes,indexes};
}
function parsePredicates(lines){
    const predMap=new Map();
    lines.split("\n").map(l=>l.trim()).filter(Boolean).forEach(r=>{
        const parts=r.split(/\s+/);
        if(parts.length<3) return;
        const t=parts[0], cond=parts[1], sel=parseFloat(parts[2]);
        predMap.set(t, sel);
    });
    return predMap;
}
function parseJoins(lines){
    const jm=new Map();
    lines.split("\n").map(l=>l.trim()).filter(Boolean).forEach(r=>{
        const [a,b,s]=r.split(/\s+/);
        jm.set(keyPair(a,b),parseFloat(s));
    });
    return jm;
}
function keyPair(a,b){ return a<b?a+"|"+b:b+"|"+a; }

// ---------- Plan nodes ----------
function ScanNode(table,rows,cost,method){
    return {kind:"scan",table,rows,cost,method,toString(){return method+"("+table+")";}};
}
function JoinNode(op,left,right,sel,rows,cost){
    return {kind:"join",op,left,right,sel,rows,cost,
        toString(indent=0){
            const pad=" ".repeat(indent);
            let s=`${pad}${op} sel=${sel.toFixed(3)} rows=${rows} cost=${cost.toFixed(2)}`;
            s+="\n"+left.toString(indent+2)+"\n"+right.toString(indent+2);
            return s;
        }
    };
}

// ---------- Cost ----------
function getCostParams(){ return {io:parseFloat(document.getElementById('ioRow').value)||1, cpu:parseFloat(document.getElementById('cpuRow').value)||0.1}; }
function costScan(rows,params,method){ return method==="IndexScan"?rows*params.cpu:rows*params.io; }
function costHashJoin(left,right,params){ return left.cost+right.cost+(left.rows+right.rows)*params.cpu; }
function costNLJ(left,right,params){ return left.cost+right.cost+(left.rows*right.rows)*params.cpu; }
function computeCutSelectivity(left,right,joinMap){ 
    const sels=[]; left.forEach(a=>right.forEach(b=>{const k=keyPair(a,b); if(joinMap.has(k)) sels.push(joinMap.get(k));}));
    if(sels.length===0) return 0.1; return sels.reduce((a,b)=>a*b,1.0);
}

// ---------- DP ----------
function popcount(x){let c=0;while(x){c+=x&1;x>>=1;}return c;}
function maskToNames(mask,idxToName){ const out=[]; for(let i=0;i<idxToName.length;i++) if(mask&(1<<i)) out.push(idxToName[i]); return out; }

function optimizeJoinOrder(tables,sizes,indexes,predMap,joinMap,params){
    const n=tables.length,N=1<<n;
    const idxToName=tables.slice(), nameToIdx={}; for(let i=0;i<n;i++) nameToIdx[tables[i]]=i;
    const dp=new Array(N).fill(null);
    for(let i=0;i<n;i++){
        const mask=1<<i; const t=idxToName[i];
        const sel=predMap.get(t)||1.0;
        const method=indexes[t]?"IndexScan":"SeqScan";
        const row=Math.floor(sizes[t]*sel);
        const cost=costScan(row,params,method);
        dp[mask]={cost,rows:row,node:ScanNode(t,row,cost,method),repr:t};
    }

    function* properSubmasks(mask){for(let sub=(mask-1)&mask;sub;sub=(sub-1)&mask){const other=mask^sub;if(other===0) continue; yield [sub,other];}}

    const masksBySize=[]; for(let sz=2;sz<=n;sz++) masksBySize.push([]);
    for(let mask=1;mask<N;mask++){const pc=popcount(mask); if(pc>=2) masksBySize[pc-2].push(mask);}
    for(const group of masksBySize){
        for(const mask of group){
            let best=null;
            for(const [lmask,rmask] of properSubmasks(mask)){
                const left=dp[lmask], right=dp[rmask]; if(!left||!right) continue;
                const leftNames=maskToNames(lmask,idxToName), rightNames=maskToNames(rmask,idxToName);
                const sel=computeCutSelectivity(leftNames,rightNames,joinMap);
                const rows=Math.max(1,Math.floor(left.rows*right.rows*sel));
                const hcost=costHashJoin(left,right,params); const ncost=costNLJ(left,right,params);
                const op=hcost<=ncost?"HashJoin":"NestedLoop"; const cst=Math.min(hcost,ncost);
                const cand={cost:cst,rows,node:JoinNode(op,left.node,right.node,sel,rows,cst),repr:`(${left.repr} ⋈ ${right.repr}) sel=${sel.toFixed(3)}`};
                if(!best||cand.cost<best.cost) best=cand;
            }
            dp[mask]=best;
        }
    }
    return {dp,full:N-1,tables:idxToName};
}

// ---------- Pretty print ----------
function prettyDP(dpStruct){
    const {dp,tables}=dpStruct,n=tables.length; const rows=[]; rows.push("mask | tables | cost | estRows | repr");
    for(let mask=1;mask<(1<<n);mask++){
        const names=maskToNames(mask,tables).join(",");
        const e=dp[mask];
        rows.push(`${mask.toString(2).padStart(n,'0')} | ${names} | ${e?e.cost.toFixed(2):"-"} | ${e?e.rows:"-"} | ${e?e.repr:"-"}`);
    }
    return rows.join("\n");
}
function drawPlanSVG(node){
    const svg=document.getElementById("planSvg"); while(svg.firstChild) svg.removeChild(svg.firstChild);
    const width=svg.clientWidth, levelHeight=60; const nodes=[];
    function traverse(n,x,y,level){
        nodes.push({n,x,y}); let dx=100;
        if(n.kind==="join"){ traverse(n.left,x-dx,y+levelHeight,level+1); traverse(n.right,x+dx,y+levelHeight,level+1);}
    }
    traverse(node,width/2,20,0);
    nodes.forEach(n=>{
        if(n.n.kind==="join"){
            const lx=n.x-100,ly=n.y+levelHeight;
            const rx=n.x+100,ry=n.y+levelHeight;
            const ns=nodes.find(x=>x.n===n.n.left); const ne=nodes.find(x=>x.n===n.n.right);
            if(ns){ const line=document.createElementNS("http://www.w3.org/2000/svg","line"); line.setAttribute("x1",n.x); line.setAttribute("y1",n.y+10); line.setAttribute("x2",ns.x); line.setAttribute("y2",ns.y-10); line.setAttribute("stroke","black"); svg.appendChild(line);}
            if(ne){ const line=document.createElementNS("http://www.w3.org/2000/svg","line"); line.setAttribute("x1",n.x); line.setAttribute("y1",n.y+10); line.setAttribute("x2",ne.x); line.setAttribute("y2",ne.y-10); line.setAttribute("stroke","black"); svg.appendChild(line);}
        }
    });
    nodes.forEach(n=>{
        const rect=document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute("x",n.x-40); rect.setAttribute("y",n.y-10); rect.setAttribute("width",80); rect.setAttribute("height",20); rect.setAttribute("fill","#cce5ff"); rect.setAttribute("stroke","#007bff");
        svg.appendChild(rect);
        const text=document.createElementNS("http://www.w3.org/2000/svg","text");
        text.setAttribute("x",n.x); text.setAttribute("y",n.y+5); text.setAttribute("text-anchor","middle"); text.setAttribute("font-size","12px"); text.setAttribute("fill","black");
        text.textContent=n.n.kind==="scan"?`${n.n.method}(${n.n.table}) rows=${n.n.rows}`:`${n.n.op} rows=${n.n.rows}`;
        svg.appendChild(text);
    });
}

// ---------- Run ----------
document.getElementById("runBtn").addEventListener("click",run);
document.getElementById("resetBtn").addEventListener("click",()=>{
    document.getElementById("tablesInput").value="A:1000:1,B:5000:0,C:2000:1";
    document.getElementById("predicatesInput").value="A col1>5 0.1\nC colX=10 0.05";
    document.getElementById("joinsInput").value="A B 0.01\nB C 0.01";
    document.getElementById("ioRow").value="1.0"; document.getElementById("cpuRow").value="0.1"; run();
});

function run(){
    const {names,sizes,indexes}=parseTables(document.getElementById("tablesInput").value);
    const predMap=parsePredicates(document.getElementById("predicatesInput").value);
    const joinMap=parseJoins(document.getElementById("joinsInput").value);
    const params=getCostParams();
    const dpStruct=optimizeJoinOrder(names,sizes,indexes,predMap,joinMap,params);
    const dp=dpStruct.dp, fullMask=dpStruct.full, best=dp[fullMask];
    document.getElementById("dpOut").innerHTML="<pre>"+prettyDP(dpStruct)+"</pre>";
    if(!best){ document.getElementById("bestOut").innerHTML="<pre>(no plan)</pre>"; return; }
    document.getElementById("bestOut").innerHTML=`<pre>Best cost: ${best.cost.toFixed(2)}\nEstimated rows: ${best.rows}\nJoin repr: ${best.repr}</pre>`;
    drawPlanSVG(best.node);
}
run();
</script>
</body>
</html>
